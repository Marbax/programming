...
...
...
<details><summary>Урок 7. Указатели</summary><p>

- Указатель это переменная ,которая может хранить в себе адрес другой переменной 
- " & " для получения адреса в памяти
- " * " разименование , позволяет получить содержимое переменной через указатель на нее

- ```int *pa = &a;```  указатель
- ```int **ppt = &pt;``` указатель на указатель
- ```pt = nullptr;``` указатель в никуда / обнуление
- ```int &ra = a;``` ссылка
- ```int *&pra = pa;``` ссылка на указатель


- Массивы неразрывно связаны со своей памятью ,их нельзя переуказывать


- Приложению изначально выделяется минимально 1МБ - stack 
- Вся остальная память(которая дальше ,после stack) - "куча" или "Heap"
    - Принцип работы памяти LIFO - первый пришедший уходит последним 
- Оператор ```new``` ищет запрошеный обьем непрерывный области памяти в  "куче"
- Для удаления есть оператор ```delete ``` , например ```delete pt;``` и ```delete[]arr;```
- Единственный способ вызвать определенные данные из "кучи" по указателю в памяти , хорошо создавать массивы в куче 
- Массивы созданные в куче - наываются Динамическими
- Запрошеная в куче память сама никогда не удалаяется(C++ нет сборщика мусора) и в плане операционной системы она занята (если она не удаляется - это утечка памяти). В C++ память из кучи сама не удаляется ,нужно в ручную , если удалять то ,чего нет - будет всегда ошибка .
- Как только программа закрывается - система чистит память сама 

- Чтобы добавить в массив новый еллемент нужно сделать 4 действия 
    - Создаем новый массив нового размера 
    - Скопировать данные из старого массива в новый
    - Удаляем старый массив
    - Перенаправляем старый массив в новую память
    
<details><summary>Например</summary><p>

```
    int *tmp = new int[size + 1];  // 1
    for (int i = 0; i < size; i++) // 2
    {
        tmp[i] = arr[i];
    }
    delete[] arr; // 3

    arr = tmp; // 4
```
</p></details>

- В языке C есть только указатели 
<details><summary>Например добавления эллемента в C</summary><p>

```

void Add_to_array_like_C(int **arr, int *size, int value) // Способ из C
{
    int *tmp = new int[*size + 1];  // 1
    for (int i = 0; i < *size; i++) // 2
    {
        tmp[i] = *(*arr + i);
    }
    delete[] * arr; // 3

    *arr = tmp; // 4
    // *(*arr+*size) = value;
    tmp[*size] = value;
    // (*size)++;
    *size = *size + 1;
}

```

</p></details>

- В C++ есть ссылки ,с ними проще и приятнее работать ,нежели с указателями 
<details><summary>Например добавления эллемента в C++</summary><p>

```

void Add_to_array(int *&arr, int &size, int value)
{
    int *tmp = new int[size + 1];  // 1
    for (int i = 0; i < size; i++) // 2
    {
        tmp[i] = arr[i];
    }
    delete[] arr; // 3

    arr = tmp; // 4
    arr[size] = value;
    size++;
}

```

</p></details>

- Чтоб узнать код символа

```
char key = getchar();
cout << int (key);
```

</p></details>

<details><summary>Урок 8.Динамические многомерные массивы </summary><p>
Динамические многомерные массивы создются иначе.
- Указатель на указзатель **arr

<details><summary>Двумерный</summary><p>
<details><summary>Создание</summary><p>
```
    int **arr = new int *[row];   //создание массива массивов
    for (int i = 0; i < row; i++) //создание двумерных подмассивов
    {
        arr[i] = new int[col];
    }
```
</p></details>

<details><summary>Удаление</summary><p>

```
    for (int i = 0; i < row; i++) // удаление двумерных подмассивов
    {
        delete[] arr[i];
    }
    delete[] arr; //удаление массива массивов
```
</p></details>
</p></details>

- Рваныые,зубчатые массивы , двумерные массивы с разной размерность строк ,благодаря созданию нового массива ,который хранит размеры строк.

- Чаровские массивы выводятся до спец символа (терминирующий символ \0)

<details><summary>прототипы, стандартные ф-и для работы со строкоми string.h</summary><p>
версия с n(напр nstrcpy) в начале названия принимает кол-во еще

```int strlen(char*)``` считает кол-во символов в строке ,без учета нуль симмвола
```char* strcpy(char*d,char*s)``` копирует символы строки, заменяет полностью с нулевого эллемента
```char* strcat(char*d,char*s)``` копирует символы строки , вставляет с конца (ищит нуль символ и с него начинает ,размер должен ,,быть выделен за ранее),нельзя юзать с пустыми массивами
размер нужно выделять самому для всех стандартных ф-й
```int strcmp(char*,char*)``` сравнивает по содержимому(возвращает 0 если одинаковые)(вычитает еллементы по индексу)
```char * strstr(char*str,char*substr)```  проверяет или есть подстрока(substr) в строке (str) и возвращает первое совпадени (адрес),если ничего не нашел вернет ноль
```char* strchur(char* str,char ch)``` проверяет или есть символ в строке 
```char* strpbrk(char* str,char* cbls)``` находит первое вхождение любого из символов второй строки
```char* strtok(char* str,char* sep)``` разбивает строку на части , второе значение набор символов , по которым разбивать
```int atoi(char*)``` asci to int переводит строку в инт, передавать только цифры ,заканчивается когда встречает буквы

только для вижуал студии
```int itoi(int,char*,int)``` число в символ переводит 

</p></details>

- 8u-replace если новая строка короче ,то ,при ресайзе (при копирование обрезает строку)
- 8u-2-replacing_array ,с помощью кнопки "ескейп" нельзя выйти и свитча (нужно юзать гетчар), так же ретерн в свитче все ломает 

- В строку возможно (но нельзя) записать больше значений ,чем выделено
</p></details>


<details><summary> Урок 9.Указатели на ф-и. Создание типов данных. Структуры. </summary><p>

### Указатели на ф-и
- Два основных вида ф-й : ф-и первого порядка и высшего порядка, ф-и первого порядка можно передавать в другие ф-и в кач-ве аргемента , а ф-и высшего порядка могут принимать в кач-ве аргумента другие ф-и.

### Создание типов данных(структура)
- Структура - конструкция ,позволяющая создать свой собственный тип. Группировка для упрощения понимания и уменьшения  кода

- ```sizeof(a);``` показывает сколько памяти выделено для выражения в скобках

</p></details>


