#include <iostream>
#include <iomanip>
#include <ctime>
#include <string.h>
using namespace std;
//----------------------------------------------------------------------------------------
/* 
void fill_array(int **arr, int row, int col) //заполнение
{
    for (int i = 0; i < row; i++)
    {
        for (int j = 0; j < col; j++)
        {
            arr[i][j] = rand() % 20;
        }
    }
}
void print_array(int **arr, int row, int col) //вывод
{
    for (int i = 0; i < row; i++)
    {
        for (int j = 0; j < col; j++)
        {
            cout << setw(3) << arr[i][j];
        }
        cout << endl;
    }
}
int main()
{
    int row = 3, col = 5;
    int **arr = new int *[row];   //создание массива массивов
    for (int i = 0; i < row; i++) //создание двумерных подмассивов
    {
        arr[i] = new int[col];
    }
    fill_array(arr, row, col);
    print_array(arr, row, col);
    for (int i = 0; i < row; i++) // удаление двумерных подмассивов
    {
        delete[] arr[i];
    }
    delete[] arr; //удаление массива массивов
}
 */
//----------------------------------------------------------------------------------------
//-----------------------------трехмерный массив------------------------------------------
/* 
int main()
{
    int x = 3, y = 4, z = 5;
    int ***arr = new int **[x];
    for (int i = 0; i < x; i++) //создание
    {
        arr[i] = new int *[y];
    }
    for (int i = 0; i < x; ++i)
    {
        for (int j = 0; j < y; ++j)
        {
            arr[i][j] = new int[z];
        }
    }
    for (int i = 0; i < x; i++) //заполнение и вывод
    {
        for (int j = 0; j < y; j++)
        {
            for (int k = 0; k < z; k++)
            {
                arr[i][j][k] = rand() % 10;
                cout << arr[i][j][k] << " ";
            }
            cout << endl;
        }
        cout << endl;
    }

    for (int i = 0; i < x; i++) //удаление
    {
        for (int j = 0; j < y; j++)
        {
            delete[] arr[i][j];
        }
    }
    delete[] arr;
}
 */
//----------------------------------------------------------------------------------------
//----------------------------двумерный массив с разным кол-вом эллементов----------------
/* 
int main()
{
    int row = 5;
    int **arr = new int *[row];
    for (int i = 0; i < row; i++)
    {
        arr[i] = new int[col[i]]; //каждый следующий подмассив больше на 1 эллемент
    }
    for (int i = 0; i < row; i++)
    {
        for (int j = 0; j < col[i]; j++)
        {
            arr[i][j] = rand() % 10;
        }
    }
    for (int i = 0; i < row; i++)
    {
        for (int j = 0; j < col[i]; j++)
        {
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }
    for (int i = 0; i < row; i++)
    {
        delete[] arr[i];
    }
    delete[] arr;
}
 */
//----------------------------------------------------------------------------------------
//--------------------------двумерный массив со строками разного размера------------------
/* 
int main()
{
    srand(time(0));
    int row = 5, *col; //добавляем массив , который будет хранить размерность подмассивов
    int **arr = new int *[row];
    col = new int[row];
    int max = 10, min = 5;
    for (int i = 0; i < row; i++)
    {
        col[i] = rand() % (max - min) + min;
        arr[i] = new int[col[i]];
    }

    for (int i = 0; i < row; i++)
    {
        for (int j = 0; j < col[i]; j++) // считаем до размерности данной ячейки
        {
            arr[i][j] = rand() % 10;
        }
    }
    for (int i = 0; i < row; i++)
    {
        for (int j = 0; j < col[i]; j++)
        {
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }
    for (int i = 0; i < row; i++)
    {
        delete[] arr[i];
    }
    delete[] arr;
    delete[] col;
}
 */
//----------------------------------------------------------------------------------------
//----------------------------------строки------------------------------------------------
/* 
int main()
{
    char arr[6] = {'H', 'E', 'L', 'L', 'O'};
    char brr[] = {'H', 'E', 'L', 'L', 'O'};
    char mas[] = "Hello"; //при наличии значения сам считает кол-во эллементов
    const char*str="bla";//плохой способ
    //char*str="bla";//еще хуже способ, нельзя заменять символы
    arr[0]='z';
    cout << arr << "\n\n"<< mas << "\n\n"<<brr<<"\n\n"<<str;;
}
 */
//----------------------------------------------------------------------------------------
//-------------------------------cin со строками------------------------------------------
/* 
int main()
{
    int age;
    cout << "Enter your age ==> ";
    cin >> age;
    cin.ignore(); //позволяет проигнорить заданное колво символов из буфера (дфолт 1 ) всегда нужно ставить поле cin если есть getline
    cout << "You'r " << age << " years old";
    char name[20];
    cout << "Enter your name ==> ";
    //cin >> name;//считывает до символа (напр прбела)
    cin.getline(name, 20); //считывает до энтера (19 символов,20й нуль символ), работает только со строками
    cout << "Hello, " << name << endl;
}
 */
//----------------------------------------------------------------------------------------
//--------------------------------------копирование еллементов строк----------------------
/* 
int s_len(const char *str) //считает кол-во символов до нуль символа,не учитывая его
{
    int count = 0;
    for (int i = 0; str[i] != '\0'; i++) // '\0' = тоже что и ноль
    {
        count++;
    }
    return count;
}
void s_copy(char *dest, const char *src) //копирует эллементы
{
    int n = 0;
    do
    {
        dest[n] = src[n];
    } while (dest[n++] != 0);
    //while(*(dest++)=*(src++)); // тоже самое что и выше ,но однострочник ,
    // но использовать только с указателями на память ,ибо можно потерять первые еллементы массива
}
int main()
{
    char buf[500];
    cout << "Enter line ==> ";
    cin.getline(buf, 500);
    int len = s_len(buf);
    cout << len;
    char *str = new char[len + 1];
    s_copy(str, buf);
    cout << "\n\n"
         << str << endl;
    delete[] str;
}
 */
//----------------------------------------------------------------------------------------
//-------------------прототипы, стандартные ф-и для работы со строкоми string.h-----------
// версия с n в начале названия принимает кол-во еще
/* 
int strlen(char*) // считает кол-во символов в строке ,без учета нуль симмвола
char* strcpy(char*d,char*s) // копирует символы строки, заменяет полностью с нулевого эллемента
char* strcat(char*d,char*s) // копирует символы строки , 
// вставляет с конца (ищит нуль символ и с него начинает ,размер должен быть выделен за ранее),нельзя юзать с пустыми массивами
// размер нужно выделять самому для всех стандартных ф-й
int strcmp(char*,char*) // сравнивает по содержимому(возвращает 0 если одинаковые)(вычитает еллементы по индексу)
char * strstr(char*str,char*substr) // проверяет или есть подстрока(substr) в строке (str) и возвращает первое совпадение(адрес),если ничего не нашел вернет ноль
char* strchur(char* str,char ch) // проверяет или есть символ в строке 
char* strpbrk(char* str,char* cbls) // находит первое вхождение любого из символов второй строки
char* strtok(char* str,char* sep) // разбивает строку на части , второе значение набор символов , по которым разбивать
int atoi(char*) // asci to int переводит строку в инт, передавать только цифры ,заканчивается когда встречает буквы

//только для вижуал студии
int itoi(int,char*,int) // число в символ переводит 
 */
//----------------------------------------------------------------------------------------
/* 
int main()
{
    char buf[500];
    cout << "Enter line ==> ";
    cin.getline(buf, 500);
    int len = strlen(buf);
    cout << len;
    char *str = new char[len + 1];
    strcpy(str, buf); //в вижуал студии нельзя юзать ,можно только их (либо добавить над инлюдами #define _CRT_SECURE_NO_WARNINGS)
    cout << "\n\n"
         << str << endl;
    delete[] str;
}
 */
//----------------------------------------------------------------------------------------
/* 
int main()
{
    char arr[] = "onetwo.three:four,five--six!!!seven    ";
    char *pt = strtok(arr, " .,:;!-"); // создает новый указатель,находит первый разделитель и заменяет его нуль символом 
    if (pt)
    {
        cout << pt << endl;
    }
    while (pt)
    {
        pt = strtok(NULL, " .,:;!-");// игнорит все символы и разделяет ими, NULL - чтобы не заменять адрес (оставляет старый адрес)
        if (pt)
        {
            cout << pt << endl;
        }
    }
}
 */
//----------------------------------------------------------------------------------------
// то же что и выше ,но короче
/* 
int main()
{
    char arr[] = " . onetwo.three:four,five--six!!!seven    ";
    char *pt = strtok(arr, " .,:;!-"); // создает новый указатель,находит первый разделитель и заменяет его нуль символом

    while (pt)
    {
        cout << pt << endl;
        pt = strtok(NULL, " .,:;!-");         {
        }
    }
}
 */
//----------------------------------------------------------------------------------------
/* 
int main()
{
    int a = 5;
    //const int *pa = &a; // а так можно указывать
    int *const cpa=&a; // константный указатель ,который нельзя перенаправлять , а менять чере него можно
    //const int *const cc_pt=&b; // константный указатель на константную переменную
    int *pa = &a;
    const int b = 12;
    pa = &b; // низя на константу указывать,т.к. нельзя ее менять
}
 */
//----------------------------------------------------------------------------------------
