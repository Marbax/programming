#include <iostream>
#include <vector>
#include <list>
#include <string>
#include <algorithm>
#include <iterator>   // доп итераторы
#include <random>     // randoms
#include <functional> // сравнения
#include <set>
#include <numeric> // для работы с числами , в ней accumulate

using namespace std;

int main()
{
    srand(time(0));

    ostream_iterator<int> osi(cout, " "); // создание обьекта итератор

    vector<int> v;

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /*     
    int min, max;
    cout << "enter min ,max" << endl;
    cin >> min >> max;
    function<int()> f = [min, max]() -> int { return rand() % (max - min) + min; }; // сохранение лямбды , но мин макс всегда один ( не меняется)
    */
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /* 
    int min, max;
    cout << "enter min ,max" << endl;
    cin >> min >> max;

    // function<fucntion<int()>(int,int)>f // то ,что находится в auto
    auto f = [](int min, int max) -> function<int()> { return [min, max]() -> int { return rand() % (max - min) + min; }; }; // лямбда в лямбде , чтоб менялись мин и макс
     */
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////Не закончен/////////////////////////////////////////////////////////////////////////////
    /* 
    int min = 1111, max = 2222;

    // function<fucntion<int()>(int,int)>f // то ,что находится в auto
    auto f = [&](int min, int max) -> function<int()> { return [&]() -> int { return rand() % (max - min) + min; }; }; // лямбда в лямбде , чтоб менялись мин и макс
 */
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////_ЛЯМБДА_В_ЛЯМБДЕ_/////////////////////////////////////////////////////////////////////////////

    int min = 1, max = 10;

    // function<fucntion<int()>(int,int)>f // то ,что находится в auto
    auto f = [](int min, int max) -> function<int()> { return [min, max]() -> int { return rand() % (max - min) + min; }; }; // лямбда в лямбде , чтоб менялись мин и макс ,захватывает их из выше обьявленных

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /* 
    int n = 1;
    generate_n(back_inserter(v), 10, [&n]() -> int { return n++; }); // принимает указатель на `n` (не меняет внешне)
    copy(v.begin(), v.end(), osi);                                   // перебирает и копирует в поток вывода через обьект вывода
    cout << endl;

    generate_n(back_inserter(v), 10, [n]() mutable -> int { return n++; }); // принимает копию на `n` (меняет внешне)
    copy(v.begin(), v.end(), osi);                                          // перебирает и копирует в поток вывода через обьект вывода
    cout << endl;
    */
    ////////////////////////////////////////////////_ОБЬЕКТ_ЛЯМБДЫ_//////////////////////////////////////////////////////////////////////////////////

    generate_n(back_inserter(v), 10, f(min, max)); // принимает лямбда выражение

    copy(v.begin(), v.end(), osi); // перебирает и копирует в поток вывода через обьект вывода
    cout << endl;

    ////////////////////////////////////////////_ПОИСК_//////////////////////////////////////////////////////////////////////////////////////

    auto it = find(v.begin(), v.end(), 8); // если не нашел то возвращает итератор на ЕНД(за пределы)

    int c_n = count(v.begin(), v.end(), 8);                                                // сколько раз встречается
    int c_nn = count_if(v.begin(), v.end(), [](int val) -> bool { return val % 2 == 0; }); // сколько раз встречается парное число

    if (it != v.end())
    {
        cout << *it << " pos = " << it - v.begin() << " val % 2 = " << c_nn << endl; // вектор умеет отнимать позиции
    }
    else
    {
        cerr << "ERROR!" << endl;
    }

    ////////////////////////////////////////////_ТРАНСФОРМ_//////////////////////////////////////////////////////////////////////////////////////
    /* 
    transform(v.begin(), v.end(), v.begin(), [](int val) -> int { return val * 2; }); // каждый эллемент умножает на 2 
    copy(v.begin(), v.end(), osi);
    cout << endl;
 */
    vector<string> vs;
    transform(v.begin(), v.end(), back_inserter(vs), [](int val) -> string { return to_string(val); }); // превращает числа в строки и засовыет в вектор строк
    copy(vs.begin(), vs.end(), ostream_iterator<string>(cout, " "));
    cout << endl;

    ////////////////////////////////////////////_accumulate_//////////////////////////////////////////////////////////////////////////////////////

    int summmmma = accumulate(v.begin(), v.end(), 0);                                          // сумма всех эллементов
    int proddd = accumulate(v.begin(), v.end(), 1, [](int a, int b) -> int { return a * b; }); // продукт всех ээлементов
    cout << "\n"
         << summmmma << " " << proddd << endl;

    ////////////////////////////////////////////_accumulate_//////////////////////////////////////////////////////////////////////////////////////

    vector<int> even_v;
    copy_if(v.begin(), v.end(), back_inserter(even_v), [](int val) -> int { return val % 2 == 0; });
    copy(even_v.begin(), even_v.end(), osi);
    cout << endl;


}
